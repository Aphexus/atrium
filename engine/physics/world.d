/*
Copyright (c) 2013 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module engine.physics.world;

private
{
    import std.algorithm;
    import std.math;
    import dlib.math.vector;
    import dlib.math.matrix3x3;
    import dlib.math.interpolation;
    import dlib.geometry.triangle;
    import dlib.geometry.intersection;
    import engine.scene.bvh;
    import engine.physics.constants;
    import engine.physics.geometry;
    import engine.physics.rigidbody;
    import engine.physics.integrator;
    import engine.physics.contact;
    import engine.physics.solver;
}

enum PhysicalEnvironment
{
    Earth
}

class PhysicsWorld
{
    RigidBody[] rigidBodies;
    
    Vector3f gravityVector;
    float gravity;
    float dampingFactor = 1.0f;
    float penetrationSolverHardness = 1.0f;
    float contactSolverHardness = 1.0f;

    uint solverIterations = 20;
    
    RigidBody gravityTarget = null;
    
    RigidBody tmpTri;
    GeomTriangle tmpTriGeom;
    
    BVHNode bvhRoot = null;
    
    Contact[] contacts;
    uint contactsNum = 0;
    
    Vector3f gravityDirection = Vector3f(0.0f, -1.0f, 0.0f);

    float fixedTimestepAccumulator = 0.0f;
    float fixedTimestepAccumulatorRatio = 0.0f;
    float FIXED_TIMESTEP = 1.0f / 60.0f;
    
    this(PhysicalEnvironment env = PhysicalEnvironment.Earth)
    {
        gravityVector = Vector3f(0.0f, -1.0f, 0.0f);
        if (env == PhysicalEnvironment.Earth)
        {
            gravity = 1.0f; //Gravity.Earth;
            gravityVector *= gravity;
        }
        
        tmpTri = new RigidBody();
        tmpTri.dynamic = false;
        tmpTri.mass = float.max;
        tmpTri.invMass = 1.0f / tmpTri.mass;
        tmpTri.inertiaMoment = 1.0f;
        tmpTri.invInertiaMoment = 1.0f / tmpTri.inertiaMoment;
        //tmpTri.inertiaTensor = identityMatrix3x3!float();
        //tmpTri.invInertiaTensor = identityMatrix3x3!float();
        Triangle tmpTriangle;
        tmpTriGeom = new GeomTriangle(tmpTriangle);
        tmpTri.setGeometry(tmpTriGeom);
        //tmpTri.dynamicFrictionCoef = 1.0f;
        //tmpTri.staticFrictionCoef = 1.0f;

        contacts = new Contact[100];
    }

    void addContact(Contact newc)
    {
        if (!newc.fact)
            return;

        foreach(ref c; contacts)
        {
            if (contactsAreSame(c, newc))
            {
                c.isec.fact = newc.isec.fact;
                c.isec.point = newc.isec.point;
                c.isec.penetrationDepth += newc.penetrationDepth;
                if (c.life < 1.0f)
                    c.life += 0.01f;
                return;
            }
        }

        int eci = firstEmptyContactIndex();
        if (eci >= 0)
            contacts[eci] = newc;
    }

    int firstEmptyContactIndex()
    {
        foreach(i, ref c; contacts)
        {
            if (!c.fact)
                return i;
        }

        return -1;
    }

    bool contactsAreSame(ref Contact c1, ref Contact c2)
    {
        return ((c1.body1 == c2.body1) &&
                (c1.body2 == c2.body2) &&
                (abs((c2.point - c1.point).length) < 0.5f));
    }

    void clearContacts()
    {
        foreach(ref c; contacts)
            if (c.penetrationDepth < 0.0001f)
                c.fact = false;
    }
    
    RigidBody addDynamicRigidBody(float mass)
    {
        RigidBody b = new RigidBody();
        b.dynamic = true;
        b.mass = mass;
        b.invMass = 1.0f / mass;
        b.inertiaMoment = mass;
        b.invInertiaMoment = 1.0f / b.inertiaMoment;
        //b.inertiaTensor = identityMatrix3x3!float();
        //b.invInertiaTensor = identityMatrix3x3!float();
        rigidBodies ~= b;
        return b;
    }
    
    RigidBody addStaticRigidBody(float mass = float.max)
    {
        RigidBody b = new RigidBody();
        b.dynamic = false;
        b.mass = mass;
        b.invMass = 1.0f / mass;
        b.inertiaMoment = mass;
        b.invInertiaMoment = 1.0f / b.inertiaMoment;
        //b.inertiaTensor = identityMatrix3x3!float();
        //b.invInertiaTensor = identityMatrix3x3!float();
        rigidBodies ~= b;
        return b;
    }
    
    void setGravityTarget(RigidBody b)
    {
        gravityTarget = b;
    }
    
    bool bodyIsOnGround(RigidBody b)
    {
        foreach(ref c; contacts)
        {
            if (c.fact)
            if ((c.body1 == b) ||
                (c.body2 == b))
            {
                if (c.point.y < b.position.y)
                    return true;
            }
        }
        
        return false;
    }

    void solverStep(uint iterations, double delta)
    {
        foreach(b; rigidBodies) 
        {
            if (b.dynamic)
                Euler.integrateVelocities(b, delta);

            b.updateGeometryTransformation();
        }
        
        for (int i = 0; i < rigidBodies.length - 1; i++)   
        for (int j = i + 1; j < rigidBodies.length; j++)
        {
            Contact c = detectContact(rigidBodies[i], rigidBodies[j]);
            addContact(c);
        }

        foreach(ref c; contacts)
        if (c.fact)
        {
            solvePenetration(c, penetrationSolverHardness);
            solveContact(c, iterations, contactSolverHardness);
            //c.fact = false;
        }
        
        // FIXME:
        // There is a problem when rolling spheres over a triangle mesh. 
        // Instead of rolling straight the sphere will get influenced when hitting triangle edges. 
        // Possible solutions:
        // Strategy 1
        // Reduce penetrationSolverHardness.
        // Strategy 2
        // Keep just the contact with deepest penetration and throw out all others.
        // Strategy 3
        // Merge all contacts that are within epsilon of each other. When merging the contacts, 
        // average and re-normalize the normals, and average the penetration depth value. 
        // In the case of spheres rolling over triangle meshes, the two contacts will be pretty 
        // much coincident, so this will work fairly well.
        
        if (bvhRoot !is null)
        foreach(rb; rigidBodies)
        {
            static Contact[5] contacts;
            static Triangle[5] contactTris;
            uint numContacts = 0;
        
            if (rb.dynamic)
            {           
                Contact c;
                c.body1 = rb;
                c.body2 = tmpTri;
                c.isec.fact = false;
                
                if (rb.geometry.type == GeometryType.Sphere)
                {
                    GeomSphere g1 = cast(GeomSphere)rb.geometry;
                    bvhRoot.traverseBySphere(g1.sphere, (ref Triangle tri)
                    {
                        Intersection isec = intrSphereVsTriangle(g1.sphere, tri);
                        if (isec.fact)
                        {
                            c.isec = isec;
                            
                            if (numContacts < contacts.length)
                            {
                                contacts[numContacts] = c;
                                contactTris[numContacts] = tri;
                                numContacts++;
                            }
                        }
                    });
                }
            }
            
            int deepestContactIdx = -1;
            float maxDepth = 0.0f;
            float bestGroundness = -1.0f;
            foreach(i; 0..numContacts)
            {
                if (contacts[i].penetrationDepth > maxDepth)
                {
                    deepestContactIdx = i;
                    maxDepth = contacts[i].penetrationDepth;
                }

                Vector3f dirToContact = 
                    (contacts[i].point - 
                     rb.position).normalized;
                
                float groundness = dot(gravityDirection, dirToContact);
                
                if (groundness > 0.9f)
                {
                    if (groundness > bestGroundness)
                    {
                        rb.lastGroundContact = contacts[i];
                        bestGroundness = groundness;
                    }
                }
            }

            if (deepestContactIdx >= 0)
            {
                tmpTriGeom.tri = contactTris[deepestContactIdx];
                tmpTri.position = tmpTriGeom.tri.barycenter;
                
                solvePenetration(contacts[deepestContactIdx], penetrationSolverHardness);
                solveContact(contacts[deepestContactIdx], iterations, contactSolverHardness);
            }
        }
        
        foreach(b; rigidBodies)
        {
            if (b.dynamic)
            {
                Euler.integratePositionAndOrientation(b, delta);
            }
        }
    }
    
    void simulate(double delta)
    {
        foreach(b; rigidBodies) 
        {
            b.savePreviousState();
            if (b.gravityEnabled)
                b.applyForce(b.mass * b.gravityDirection * gravity);
        }

        foreach(i; 0..solverIterations)
        {
            solverStep(solverIterations, delta);
        }

        foreach(b; rigidBodies) 
        {
            b.resetForces();
        }
    }

    void process(double dt)
    {
        uint MAX_STEPS = 10;
        fixedTimestepAccumulator += dt;
        uint nSteps = cast(uint)floor(fixedTimestepAccumulator / FIXED_TIMESTEP);
 
        if (nSteps > 0)
        {
            fixedTimestepAccumulator -= nSteps * FIXED_TIMESTEP;
        }
        fixedTimestepAccumulatorRatio = fixedTimestepAccumulator / FIXED_TIMESTEP;
        uint nStepsClamped = min2(nSteps, MAX_STEPS);

        for (uint i = 0; i < nStepsClamped; ++i)
        {
            simulate(FIXED_TIMESTEP);
        }

        foreach(b; rigidBodies)
        {
            if (b.dynamic)
            {
                b.finalPosition = lerp(b.prevPosition, b.position, fixedTimestepAccumulatorRatio); 
                b.finalOrientation = dlib.math.quaternion.slerp(b.prevOrientation, b.orientation, fixedTimestepAccumulatorRatio);
            }
        }
    }

    void process2(double dt)
    {
        simulate(1.0/60.0);

        foreach(b; rigidBodies)
        {
            if (b.dynamic)
            {
                b.finalPosition = lerp(b.prevPosition, b.position, 1.0f); 
                b.finalOrientation = dlib.math.quaternion.slerp(b.prevOrientation, b.orientation, 1.0f);
            }
        }
    }
}

T min2(T) (T a, T b)
{
    if (a < b) return a;
    else return b;
}

