/*
Copyright (c) 2016 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module atrium;

import std.stdio;
import std.math;

import dlib.core.memory;
import dlib.core.stream;
import dlib.math.vector;
import dlib.math.affine;
import dlib.math.quaternion;
import dlib.math.utils;
import dlib.geometry.triangle;
import dlib.image.color;
import dlib.filesystem.filesystem;
import dlib.container.array;

import dgl.core.api;
import dgl.core.event;
import dgl.core.application;
import dgl.core.interfaces;

import dgl.templates.app3d;
import dgl.templates.freeview;

import dgl.graphics.entity;
import dgl.graphics.camera;
import dgl.graphics.shapes;
import dgl.graphics.material;
import dgl.graphics.texture;
import dgl.graphics.shader;
import dgl.graphics.shadow;
import dgl.graphics.state;
import dgl.graphics.light;
import dgl.graphics.pbrshader;
import dgl.graphics.sprite;
import dgl.graphics.pass;
import dgl.graphics.rtt;
import dgl.graphics.postprocessing;
import dgl.graphics.scene;

import dgl.asset.dgl3;
import dgl.asset.envtexture;

import dmech.world;
import dmech.bvh;
import dmech.geometry;
import dmech.rigidbody;
import dmech.shape;

import game.modelbvh;
import game.physicsentity;
import game.character;
import game.fpcamera;
import game.weapon;
import game.gravitygun;
import game.audio;
import game.kinematic;

class BoxEntity: PhysicsEntity
{
    //Light light;
    
    AudioPlayer player;
    ALuint hitSoundBuf;
    ALuint hitShound;
    bool playHitSound = false;

    this(Drawable d, RigidBody rb, uint shapeIndex = 0)
    {
        super(d, rb, shapeIndex);
    }
    
    void setHitSound(AudioPlayer player, ALuint buf)
    {
        this.player = player;
        hitShound = player.addSource(buf, Vector3f(0, 0, 0));
        playHitSound = true;
    }
    
    override void update(double dt)
    {
        super.update(dt);
        //if (light)
        //    light.position = transformation.translation;
    }
    
    override void onHardCollision(float velProj)
    {
        if (playHitSound)
        {
            if (!player.isSourcePlaying(hitShound))
            {
                player.setSourcePosition(hitShound, getPosition());
                float volume = clamp(velProj / 8.0f, 0.0f, 1.0f);
                player.setSourceVolume(hitShound, volume);
                player.playSource(hitShound);
            }
        }
    }
}

Vector2f lissajousCurve(float t)
{
    return Vector2f(sin(t), cos(2 * t));
}

class EnvironmentSphere: Drawable
{
    Camera camera;
    ShapeSphere sphere;
    float radius = 50.0f;
    
    this(Camera cam)
    {
        camera = cam;
        sphere = New!ShapeSphere(1);
    }
    
    void draw(double dt)
    {
        glPushMatrix();
        Vector3f pos = camera.getTransformation.translation;
        glTranslatef(pos.x, pos.y, pos.z);
        glRotatef(180.0f, 0, 1, 0);
        glRotatef(-90.0f, 1, 0, 0);
        glScalef(-radius, -radius, -radius);
        glDisable(GL_LIGHTING);
        glDepthMask(GL_FALSE);
        sphere.draw(dt);
        glDepthMask(GL_TRUE);
        glEnable(GL_LIGHTING);
        glPopMatrix();
    }
    
    ~this()
    {
        Delete(sphere);
    }
}

enum SHADOW_GROUP = 100;

class Simple3DApp: Application3D
{
    DynamicArray!Object objects;

    Freeview freeview;
    DGL3Resource level;
    DGL3Resource gunModel;
    DGL3Resource boxModel;
    
    ShadowMapPass shadow; 
    
    RenderToTexture rtt1;
    RenderToTexture rtt2;
    LensDistortionFX ldfx;
    
    PBRShader pbrShader;
    
    EnvironmentSphere envSphere;
    Material envMat;
    EnvTextureResource ambTexRes;
    
    PhysicsWorld world;
    BVHTree!Triangle bvh;
    enum fixedTimeStep = 1.0 / 60.0;
    
    ShapeBox sBox;
    GeomBox gFloor;
    GeomBox gBox;
    
    DynamicArray!BoxEntity pEntities;
    
    GeomEllipsoid gSphere;
    GeomBox gSensor;
    CharacterController ccPlayer;
    FirstPersonView fpsView;
    
    Weapon weapon;
    GravityGun eGravityGun;  
    
    GeomSphere gSphere2;

    GeomBox gPlatform;
    KinematicController platform; 
    ShapeBox sPlatform;
    PhysicsEntity pePlatform; 
    
    AudioPlayer player;
    ALuint footstepBuffer[2];
    uint footstepIndex = 0;
    ALuint footstepSound;
    ALuint metalHitBuffer;
    
    Pass2D opaquePass;
    Scene opaqueScene;
    
    Pass3D distortionPass;
    Scene distortionScene;
    
    Pass3D weaponPass;
    Scene weaponScene;
    
    ScreenSprite rttSpr;
    Material mRendered;
    Shader distortionShader;
    
    ScreenSprite finalImage;
    
    this()
    {
        super();
        
        player = new AudioPlayer();
        player.setListener(Vector3f(0, 0, 0), Vector3f(0, 0, 1), Vector3f(0, 1, 0));
        
        GenericSound footstep1 = loadWAV("data/sounds/footstep-metal1.wav");
        GenericSound footstep2 = loadWAV("data/sounds/footstep-metal2.wav");
        GenericSound hitMetal = loadWAV("data/sounds/metal-hit.wav");
        footstepBuffer[0] = player.addBuffer(footstep1);
        footstepBuffer[1] = player.addBuffer(footstep2);
        metalHitBuffer = player.addBuffer(hitMetal);
        footstepSound = player.addSource(footstepBuffer[0], Vector3f(0, 0, 0));

        Quaternionf sunLightRot = 
            rotationQuaternion(1, degtorad(0.0f)) *
            rotationQuaternion(0, degtorad(-90.0f));

        if (useShadows)
        {
            PipelineState.shadowMapSize = 2048;
            shadow = New!ShadowMapPass(PipelineState.shadowMapSize, scene3d, SHADOW_GROUP, eventManager);
            addPass3D(shadow);
            shadow.lightRotation = sunLightRot;
            shadow.projectionSize = 20;
            shadow.depth = 1;
        }

        opaqueScene = New!Scene;
        distortionScene = New!Scene;
        weaponScene = New!Scene;

        rtt1 = New!RenderToTexture(eventManager.windowWidth, eventManager.windowHeight);
        pass3d.renderTarget = rtt1;
        pass3d.depth = 0;

        LightManager.sunEnabled = true;
        LightManager.sunPosition = Vector4f(sunLightRot.rotate(Vector3f(0, 0, 1)));
        LightManager.sunPosition.w = 0.0f;
        LightManager.sunColor = Color4f(0.7, 0.9, 0.7, 1);
        
        Material.setFogDistance(10, 30);
        Material.setFogColor(Color4f(0.051, 0.153, 0.118, 1.0));
        
        setDefaultLoadingImage("data/loading.png");
        
        mountDirectory("data");
        mountDirectory("data/level");
        mountDirectory("data/gravitygun");

        ambTexRes = addEnvironmentTexureResource("envmap3.png");
        level = addModelResource("level.dgl3");
        gunModel = addModelResource("gravitygun.dgl3");
        boxModel = addModelResource("box.dgl3");
        auto texRes = addTextureResource("dist.png");
        auto texRes2 = addTextureResource("distmask.png");
        
        loadResources();
        
        world = New!PhysicsWorld(1000);
        world.positionCorrectionIterations = 20;
        bvh = modelBVH(level);
        world.bvhRoot = bvh.root;
        
        gBox = New!GeomBox(Vector3f(0.5, 0.5, 0.5)); // Physical shape
        sBox = New!ShapeBox(Vector3f(0.25, 0.25, 0.25)); // Graphical shape
        
        foreach(i; 0..8)
            addBoxEntity(Vector3f(0, 2 + i * 1.6, 4));
        
        freeview = New!Freeview(eventManager);
        
        envSphere = New!EnvironmentSphere(freeview.camera);
        auto envSphereEntity = createEntity3D(envSphere);
        envMat = New!Material();
        envMat.textures[0] = ambTexRes.texture;
        envSphereEntity.material = envMat;
        
        if (useShaders) 
        { 
            pbrShader = New!PBRShader;
            scene3d.defaultMaterial.setShader(pbrShader);
        }
                
        addObjectsFromModel(level);
        applyShader(boxModel.entitiesByName["eBox"]);

        // Create character
        Vector3f playerPos = Vector3f(0, 2, 12);
        Vector3f playerRot = Vector3f(0, 0, 0);
        if ("spawnPos" in level.entitiesByName)
        {
            playerPos = level.entitiesByName["spawnPos"].position;
            playerRot = -level.entitiesByName["spawnPos"].rotation.toEulerAngles;
            
        }
        
        gSphere = New!GeomEllipsoid(Vector3f(0.9f, 1.0f, 0.9f));
        gSensor = New!GeomBox(Vector3f(0.5f, 0.5f, 0.5f));
        ccPlayer = New!CharacterController(world, playerPos, 80.0f, gSphere);
        ccPlayer.rotation = playerRot;
        ccPlayer.createSensor(gSensor, Vector3f(0.0f, -0.75f, 0.0f));
        
        fpsView = New!FirstPersonView(eventManager, playerPos);
        fpsView.camera.eyePosition = Vector3f(0, 0, 0);
        fpsView.camera.gunPosition = Vector3f(0.15f, -0.2f, -0.2f);
        fpsView.camera.pitch = radtodeg(playerRot.x);
        fpsView.camera.turn = radtodeg(playerRot.y);
        fpsView.camera.roll = radtodeg(playerRot.z);
                
        gSphere2 = New!GeomSphere(0.25f);
        auto se2 = addSphereEntity(Vector3f(0, 20, 4));
        se2.material = level.materialsByName["redpaint.mat"];
        
        gPlatform = New!GeomBox(Vector3f(1.0f, 1.0f, 1.0f));
        platform = New!KinematicController(world, Vector3f(0, 1, -3), gPlatform);
        sPlatform = New!ShapeBox(Vector3f(1.0f, 1.0f, 1.0f));
        pePlatform = New!PhysicsEntity(sPlatform, platform.rbody);
        distortionScene.addEntity(pePlatform);

        mRendered = New!Material();
        mRendered.textures[0] = rtt1.texture;
        mRendered.textures[1] = texRes.texture;
        mRendered.textures[2] = texRes2.texture;
        mRendered.textures[3] = rtt1.depthTexture;
        mRendered.shadeless = true;
        
    string vp = q{
        void main()
        {	
            gl_Position = ftransform();		
            gl_TexCoord[0] = gl_MultiTexCoord0;
        }
    };
    
    string fp = q{
        uniform sampler2D dgl_Texture0;
        uniform sampler2D dgl_Texture1;
        uniform sampler2D dgl_Texture2;
        uniform sampler2D dgl_Texture3; // depth texture
        uniform vec2 dgl_WindowSize;
        const float dgl_Time = 1.0;
        
        const float distortionFactor = 0.05; // Factor used to control severity of the effect
        const float riseFactor = 1.0; // Factor used to control how fast air rises

        void main()
        {        
            vec2 texcoord = gl_FragCoord.xy / dgl_WindowSize;
            float mask = texture2D(dgl_Texture2, gl_TexCoord[0].st).r;
            float z = (2.0 * gl_FragCoord.z - gl_DepthRange.near - gl_DepthRange.far) / (gl_DepthRange.far - gl_DepthRange.near);

            vec2 distortionMapCoordinate = gl_TexCoord[0].st;
            //distortionMapCoordinate.t -= dgl_Time * riseFactor;
            vec4 distortionMapValue = texture2D(dgl_Texture1, distortionMapCoordinate);
            vec2 distortionPositionOffset = (distortionMapValue.xy) * 2.0 * distortionFactor;
            distortionPositionOffset *= (1.0 - gl_TexCoord[0].t);
            vec2 distortedTextureCoordinate = texcoord + distortionPositionOffset;
            vec2 tc = distortedTextureCoordinate * mask + texcoord * (1.0 - mask);
            vec4 col1 = texture2D(dgl_Texture0, tc);
            
            float depth = texture2D(dgl_Texture3, texcoord).r;
            //if (depth < z)
            //    gl_FragColor = texture2D(dgl_Texture0, texcoord);
            //else
               gl_FragColor = col1;
            //gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0) * depth;
            gl_FragColor.a = 1.0;
        }
    };
    
        distortionShader = New!Shader(vp, fp);
        mRendered.setShader(distortionShader);
        pePlatform.material = mRendered;
        
        rttSpr = New!ScreenSprite(eventManager, rtt1.texture);
        opaqueScene.createEntity(rttSpr);
        opaquePass = addPass2D(opaqueScene);
        opaquePass.depth = -2;
        
        distortionPass = addPass3D(distortionScene);
        distortionPass.depthSource = rtt1;
        distortionPass.clear = false;
        distortionPass.depth = -3;
        
        rtt2 = New!RenderToTexture(eventManager.windowWidth, eventManager.windowHeight);
        distortionPass.renderTarget = rtt2;
        opaquePass.renderTarget = rtt2;
        
        weaponPass = addPass3D(weaponScene);
        weaponPass.depth = -4;
        weaponPass.clear = false;
        weaponPass.depthSource = rtt1;
        weaponPass.renderTarget = rtt2;

        pass2d.depth = -5;
        if (useLensDistortion)
        {
            ldfx = New!LensDistortionFX(eventManager, rtt2.texture);
            createEntity2D(ldfx);
        }
        else
        {
            finalImage = New!ScreenSprite(eventManager, rtt2.texture);
            createEntity2D(finalImage);
        }
        
        auto eGG = gunModel.entitiesByName["eWeapon"];
        Vector3f bulletStartPos = Vector3f(0, 0, -0.5);
        if ("eBulletStart" in gunModel.entitiesByName)
            bulletStartPos = gunModel.entitiesByName["eBulletStart"].position;
        eGravityGun = New!GravityGun(eGG, null, fpsView.camera, eventManager, lightManager, world, bulletStartPos, player);
        weapon = eGravityGun;
        eGravityGun.transparent = true;
        weaponScene.addEntity(eGravityGun);
        applyShader(eGG);
    }
    
    static bool useShaders()
    {
        return Material.isShadersEnabled &&
               configIsTrue("fxShadersEnabled");
    }
    
    static bool useShadows()
    {
        return useShaders() &&
               configIsTrue("fxShadowEnabled") &&
               ShadowMapPass.supported;
    }
    
    static bool useLensDistortion()
    {
        return useShaders() &&
               configIsTrue("fxLensDistortionEnabled") &&
               RenderToTexture.supported &&
               LensDistortionFX.supported;
    }
    
    BoxEntity addSphereEntity(Vector3f pos)
    {
        auto bBox = world.addDynamicBody(pos, 0.0f);
        bBox.maxSpeed = 0.15f * 60.0f;
        auto scBox = world.addShapeComponent(bBox, gSphere2, Vector3f(0, 0, 0), 50.0f);
        BoxEntity peBox = New!BoxEntity(level.entitiesByName["eSphere"].model, bBox);
        peBox.setHitSound(player, metalHitBuffer);
        if (useShadows && shadow)
            peBox.groupID = SHADOW_GROUP;
        pEntities.append(peBox);
        addEntity3D(peBox);
        return peBox;
    }
    
    BoxEntity addBoxEntity(Vector3f pos)
    {
        auto bBox = world.addDynamicBody(pos, 0.0f);
        bBox.maxSpeed = 0.7f * 60.0f;
        auto scBox = world.addShapeComponent(bBox, gBox, Vector3f(0, 0, 0), 50.0f);
        BoxEntity peBox = New!BoxEntity(boxModel.entitiesByName["eBox"], bBox);
        peBox.setHitSound(player, metalHitBuffer);
        if (useShadows && shadow)
            peBox.groupID = SHADOW_GROUP;
        pEntities.append(peBox);
        addEntity3D(peBox);
        return peBox;
    }
    
    EnvTextureResource addEnvironmentTexureResource(string filename)
    {
        EnvTextureResource res = New!EnvTextureResource(resourceManager.imageFactory);
        resourceManager.addResource(filename, res);
        return res;
    }
    
    void addObjectsFromModel(DGL3Resource model)
    {
        foreach(e; model.entities)
        {
            addEntity3D(e);
            applyShader(e);
        }
        
        foreach(l; model.lights)
        {
            addLight(l);
        }
    }

    ~this()
    {
        if (pbrShader)
            Delete(pbrShader);
        Delete(freeview);
        Delete(envSphere);
        Delete(envMat);
        
        Delete(world);
        bvh.free();
        
        Delete(sBox);
        Delete(gBox);
        
        foreach(e; pEntities)
            Delete(e);
        pEntities.free();

        Delete(gSphere);
        Delete(gSensor);
        Delete(ccPlayer);
        Delete(fpsView);
        
        Delete(gSphere2);
        
        Delete(gPlatform);
        Delete(platform);
        Delete(sPlatform);
        Delete(pePlatform);
        
        Delete(eGravityGun);
        
        if (ldfx)
            Delete(ldfx);
            
        if (finalImage)
            Delete(finalImage);
            
        Delete(rtt1);
        Delete(rtt2);
        
        Delete(opaqueScene);
        Delete(distortionScene);
        Delete(weaponScene);
        
        Delete(rttSpr);
        
        Delete(mRendered);
        Delete(distortionShader);
        
        player.close();
    }
    
    bool playerWalking = false;
    
    void playerControl()
    {   
        playerWalking = false;
    
        Vector3f forward = fpsView.camera.transformation.forward;
        Vector3f right = fpsView.camera.transformation.right;
        
        ccPlayer.rotation.y = fpsView.camera.turn;
        enum float speed = 4.0f;
        if (eventManager.keyPressed['w']) { ccPlayer.move(forward, -speed); playerWalking = true; }
        if (eventManager.keyPressed['s']) { ccPlayer.move(forward, speed); playerWalking = true; }
        if (eventManager.keyPressed['a']) { ccPlayer.move(right, -speed); playerWalking = true; }
        if (eventManager.keyPressed['d']) { ccPlayer.move(right, speed); playerWalking = true; }
        if (eventManager.keyPressed[SDLK_SPACE]) ccPlayer.jump(1.0f);
        
        playerWalking = playerWalking && ccPlayer.onGround;

        weapon.shoot();
    }
    
    float camSwayTime = 0.0f;
    float gunSwayTime = 0.0f;
    
    void swayControl()
    {
        if (playerWalking && !ccPlayer.flyMode)
        {
            gunSwayTime += 7.0f * eventManager.deltaTime;
            camSwayTime += 7.0f * eventManager.deltaTime;
        }
        else
        {
            gunSwayTime += 1.0f * eventManager.deltaTime;
        }
        
        if (gunSwayTime >= 2.0f * PI)
            gunSwayTime = 0.0f;
        if (camSwayTime >= 2.0f * PI)
            camSwayTime = 0.0f;
        
        Vector2f gunSway = Vector2f(0, 0);
        gunSway = lissajousCurve(gunSwayTime) / 10.0f;
                
        weapon.position = Vector3f(gunSway.x * 0.1f, gunSway.y * 0.1f, 0.0f);
        
        Vector2f camSway = lissajousCurve(camSwayTime) / 10.0f;          
        fpsView.camera.eyePosition = Vector3f(0, 0.5, 0) + 
            Vector3f(camSway.x, camSway.y, 0.0f);
        fpsView.camera.roll = -camSway.x * 5.0f;
    }
    
    double time = 0.0;
    
    override void onUpdate(double dt)
    {
        swayControl();
                   
        time += dt;
        if (time >= fixedTimeStep)
        {
            time -= fixedTimeStep;
            
            playerControl();
            
            platform.rbody.angularVelocity = Vector3f(0, 0.2, 0);
            //platform.position = platformPos;
            platform.update(fixedTimeStep);
            
            ccPlayer.update();
            world.update(fixedTimeStep);
            
            fpsView.camera.position = ccPlayer.rbody.position;
            fpsView.camera.turn += ccPlayer.selfTurn;
        }
        
        fpsView.update(dt);
        setCameraMatrix(fpsView.getCameraMatrix());
        distortionPass.modelViewMatrix = fpsView.getCameraMatrix();
        weaponPass.modelViewMatrix = fpsView.getCameraMatrix();

        if (Material.uberShader)
            Material.uberShader.setViewMatrix(fpsView.camera);
        if (pbrShader)
            pbrShader.setViewMatrix(fpsView.camera);
        
        if (shadow)
        {
            Vector3f pos = fpsView.camera.position - fpsView.camera.transformation.forward * 7.0f;
            shadow.lightPosition = pos;
            shadow.update(dt);
        }
        
        super.onUpdate(dt); 
        distortionScene.update(dt);
        weaponScene.update(dt);
            
        if (playerWalking && !ccPlayer.flyMode)
        {
            if (!player.isSourcePlaying(footstepSound))
            {
                player.setSourceBuffer(footstepSound, footstepBuffer[footstepIndex]);
                footstepIndex = !footstepIndex;
                player.playSource(footstepSound);
            }
        }
        
        player.setListener(
            fpsView.camera.position,
            -fpsView.camera.transformation.forward, 
            fpsView.camera.transformation.up);
    }
    
    override void onRedraw(double dt)
    {
        if (shadow)
            shadow.bind(fpsView.camera.getTransformation());       
        super.onRedraw(dt);
        if (shadow)
            shadow.unbind();
    }

    void applyShader(Entity e)
    {
        if (useShadows && shadow)
            e.groupID = SHADOW_GROUP;

        if (e.material)
        {
            if (!e.material.castShadows)
            {
                e.groupID = 0;
            }
        
            if (!useShadows || shadow is null)
            {
                e.material.receiveShadows = false;
                e.material.castShadows = false;
            }
                
            if (useShaders && pbrShader.supported)
            {
                e.material.setShader(pbrShader);                    
                ambTexRes.applyToMaterial(e.material);
            }
            else
            {
                e.material.textures[1] = null;
                e.material.textures[2] = null;
                e.material.textures[3] = null;
                e.material.textures[4] = null;
            }
        }
    }

    override void onKeyDown(int key)
    {
        if (key == SDLK_RETURN)
        {
            fpsView.switchMouseControl();
            fpsView.paused = !fpsView.paused;
        }
        else if (key == SDLK_ESCAPE)
        {
            exit();
        }
    }
}

void main()
{
    writefln("Allocated memory: %s byte(s)", allocatedMemory);
    initDGL();
    auto app = New!Simple3DApp();
    app.run();
    Delete(app);
    deinitDGL();
    writefln("Allocated memory: %s byte(s)", allocatedMemory);
}
